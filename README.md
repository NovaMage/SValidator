SValidator
==========

A framework for validation of scala objects in a fluent and concise way.

This project is heavily inspired by the [FluentValidation library for .NET](http://fluentvalidation.codeplex.com/)

Usage
=====

Consider the following case class.

```scala
case class Person(firstName: String,
                  lastName: String,
                  age: Int,
                  married: Boolean,
                  hasJob: Boolean,
                  notes: Option[String])
```

In order to validate instances of the class, we create a class that extends `SimpleValidator[A]`, where A is the type of the object that we want to validate.  In this case, we would have to extend `SimpleValidator[Person]`.

We have to override the method `buildRules` in the given class with rules used to validate the instance.  So far, we have this:

```scala

//Import SValidator classes into scope
import com.github.novamage.svalidator.validation.simple.SimpleValidator
import com.github.novamage.svalidator.validation.IRuleBuilder

class PersonValidator extends SimpleValidator[Person] {

  override def buildRules: List[IRuleBuilder[Person]] = ???

}
```

We created the class `PersonValidator` that extends `SimpleValidator[Person]`.  Note that in this case, since we don't use any constructor parameters we could have as well used an object instead.

The `buildRules` method on SimpleValidator returns a list of `RuleBuilder[A]`, this case that would translate to `RuleBuilder[Person]` as this the type we specified for A.  To create the `List[RuleBuilder[Person]]` we will use a series of conveniency methods inherited from `SimpleValidator[Person]`.

---

*For the sake of space, only the buildRules method is shown in the following examples*

---

The starting point for creating a RuleBuilder is the `For` method.  This method allows us to specify a function expression (normally a property of the object, although it can be any arbitrary expression) to extract and perform validation on. A quick example :

```scala
  override def buildRules: List[IRuleBuilder[Person]] = List(
    For { _.firstName }
  )
```

By doing this, we start defining a rule builder that will be applied to the `firstName` field of the object.  However, this particular code does not yet generate a RuleBuilder, thus, it does not compile.  In order to compile, it is mandatory to associate a field name to the object field.  This is because currently it is impossible in scala to extract the name of the property unless the expression is reified, and this not yet available as of scala 2.10.0 (reflection is still experimental).  Thus, we must call the `ForField` method on the returned builder, and pass in either a `Symbol` or a `String` as the field name.

```scala
  override def buildRules: List[IRuleBuilder[Person]] = List(
    For { _.firstName } ForField 'firstName
  )
```

The field name passed using `ForField` will be associated to the `ValidationFailures` generated by the RuleBuilder.  This name can then be used by the HTML helpers to generate input fields with their respective error messages(more on this topics later).  For now, we have initialized our very first rule builder, so the code compiles.  However, we have not added any rules to the rule builder yet.

To add a rule, the most basic way is the method `must` on the RuleBuilder.  This method receives a function of type `(A => Boolean)` where A is the type returned by the expression in the `For` clause.  In this case, firstName is a String, so it receives a function that receives an string and returns a boolean.  Let's validate that the firstName is not empty.

```scala
  override def buildRules: List[IRuleBuilder[Person]] = List(
    For { _.firstName } ForField 'firstName
        must { _.length > 0 }
  )
```

This validator would currently validate that the firstName is not empty, but no error message is specified.  To properly rule finish the builder, we should add an error message.

```scala
  override def buildRules: List[IRuleBuilder[Person]] = List(
    For { _.firstName } ForField 'firstName
        must { _.length > 0 } withMessage "First name can not be empty"
  )
```

---

_**Note** : currently the implementation of the builder allows for the "withMessage" method to be optional, however it is not prepared to handle it's omission.  Please always use the withMessage to provide a message.  It is intended that in the future automatic messages will be bound to the field if the clause is omitted, but the implementation does not yet handle this_

---

While the previous code is syntactically correct, it is not completely aware of certain possible values of `firstName`.  What if `firstName` is null?  The code would cause a runtime exception with a null pointer when trying to get the length field.  To prevent this, we add an additional rule before the previous rule.

```scala
  override def buildRules: List[IRuleBuilder[Person]] = List(
    For { _.firstName } ForField 'firstName
        must { _ != null } withMessage "First name is required"
        must { _.length > 0 } withMessage "First name can not be empty"
  )
```

When the rule builder is evaluated, the validation stops after the first failure for each field.  Therefore, if the firstName is null, the second rule is no longer evaluated.  Alternatively, we could have set the condition to `{x => x != null && x.length > 0 }` but it is recommended keeping conditions as simple as possible for easy reading.

For a further increase in readability, it is recommended to define methods or function variables to hold the conditions.  For example:

```scala

  val notBeNull:(String => Boolean) = { _ != null }
  val notEmpty:(String => Boolean) = { _.length > 0 }

  override def buildRules: List[IRuleBuilder[Person]] = List(

    For { _.firstName } ForField 'firstName
        must notBeNull withMessage "First name is required"
        must notEmpty withMessage "First name can not be empty"
  )
```

We can validate several fields by creating multiple rule builders using `For` by separating them with commas.  After all, the `buildRules` returns a List of RuleBuilders.


```scala

  val notBeNull:(String => Boolean) = { _ != null }
  val notEmpty:(String => Boolean) = { _.length > 0 }

  override def buildRules: List[IRuleBuilder[Person]] = List(

    For { _.firstName } ForField 'firstName
        must notBeNull withMessage "First name is required"
        must notEmpty withMessage "First name can not be empty",

    For { _.lastName } ForField 'lastName
        must notBeNull withMessage "Last name is required"
        must notEmpty withMessage "Last name can not be empty"
  )
```

In order to evaluate a validator on an instance, create an instance of the validator (or use the object directly if using an object instead of a class) and call the
`validate` method passing the instance.

```scala
    val sut: IValidate[Person] = new PersonValidator

    val instance = Person(
      firstName = "John",
      lastName = "Smith",
      age = 25,
      married = true,
      hasJob = true,
      notes = Some("notes"))

    val validationSummary = sut.validate(instance)
```

After evaluation, a `ValidationSummary` is returned.  Let's look at the definition a few interesting classes related to `ValidationSummary`:

```scala
case class ValidationSummary(validationFailures: List[ValidationFailure]) {

  def isValid = validationFailures.isEmpty
}

sealed abstract class ValidationResult {

  def isValid: Boolean
  def message: String

}

object ValidationPass extends ValidationResult {
  def isValid = true
  def message = ""
}

case class ValidationFailure(fieldName: String, private val errorMessage: String) extends ValidationResult {
  def isValid = false
  def message = errorMessage
}
```

A validation summary contains a list of the ValidationFailures extracted from the validation.  A `ValidationFailure` is a type of validation result that contains a fieldName and a message property(the field provided using `ForField`, and the error message provided using `withMessage`).  This list provides us with informaiton of the failures, and can be used to determine how should we proceed depending on whether the instance is valid or not.  Also, it provides for information necessary for the HTML builders to display the errors with their offending fields.  As a conveniency, the ValidationSummary has the method `isValid` that tells use whether any failures actually occurred.

Using SValidation Constructs
----------------------------

While using the `must` method for building is great, there are certain common operations performed when validating.  To make this easier, and to maintain a very concise and fluent syntax, let us introduce *constructs*.  Constructs are a series of helper classes that provide views(aka 'extension methods') to enable easy building of common validation rules.  Currently, the following constructs are available:

+ be
+ have
+ equal

To enable the use of construcs, import `com.github.novamage.svalidator.validation.simple.constructs._` into the scope.  Here's a sample usage:

```scala
import com.github.novamage.svalidator.validation.simple.SimpleValidator
import com.github.novamage.svalidator.validation.IRuleBuilder
import com.github.novamage.svalidator.validation.simple.constructs._

class PersonValidator extends SimpleValidator[Person] {

  override def buildRules: List[IRuleBuilder[Person]] = List(

    For { _.firstName } ForField 'firstName
      mustNot be empty () withMessage "First name is required"
      must have maxLength 32 withMessage "Must have 32 characters or less",

    For { _.lastName } ForField 'lastName
      mustNot be empty () withMessage "Last name is required"
      must have maxLength 32 withMessage "Must have 32 characters or less",

    For { _.age } ForField 'age
      mustNot be negative () withMessage "Must be a positive number",

    For { _.hasJob } ForField 'hasJob
      must equal(true) withMessage "Come on! Get a job! XD"

    )
}
```

The `be` and `have` constructs provide a series of convenient methods according to the type of the field being validated.  For example, for fields of type String(such as firstName) the `empty()` view method is provided.  But for Int fields such as `age`, a method `negative()` is provided.  Additionaly, by importing the
`com.github.novamage.svalidator.validation.simple.constructs._`, the `mustNot` view method is implicitly added.  This method works exactly like the `must` method does, except that it negates the function passed into it.  And, also, this method supports the constructs that the `must` method supports(be,have,equal).

As an added bonus, any additional method that is added by you to the `be` or `have` construct extensions works transparently with both the `must` and `mustNot` methods, as the negation is handed behind the scenes at a functional level (i.e. the function is negated).  Therefore, it is not necessary adding a `notEmpty` method for `must be notEmpty()`, since this can be perfectly achieved by using the `mustNot be empty()` and the handling of the validating method is simply negated behind the scenes.

Finally, the `equal(value:A)` function construct simply returns an equality function that validates that the field is equal to the passed in value.  This can be seen on the validation of the `hasJob` field above.  Also, just for syntactic sugar purposes, the `be` construct can be used in a similar way, by passing in a value directly instead of using one of the methods provided implicitly.


Conditional Validation
----------------------

It is possible to enforce validation of a field only if another field, or the instance as a whole, meets certain requirements.  For instance, take this example:

```scala
  override def buildRules: List[IRuleBuilder[Person]] = List(

    For { _.firstName } ForField 'firstName
      mustNot be empty () withMessage "First name is required"
      must have maxLength 32 withMessage "Must have 32 characters or less",

    For { _.lastName } ForField 'lastName
      mustNot be empty () withMessage "Last name is required"
      must have maxLength 32 withMessage "Must have 32 characters or less",

    For { _.age } ForField 'age
      mustNot be negative () withMessage "Must be a positive number",

    For { _.married } ForField 'married
      must be(false) when { _.age < 18 } withMessage "Must be 18 years or older to allow marking marriage",

    For { _.hasJob } ForField 'hasJob
      must be(false) when { _.age < 21 } withMessage "Must be 21 years or older to allow marking a job"
    )
```

By using the `when` clause, you can add conditional stamenents to fields only under specific circumstances, as shown.

Final Notes
===========

This is a work in progress and implementation is subject to change, but so far you might have grabbed a general idea of the direction of the framework and
its usage.


