package com.github.novamage.svalidator.testing

import com.github.novamage.svalidator.testing.exceptions.ValidationTestingException
import com.github.novamage.svalidator.validation.{ValidationFailure, ValidationWithData}

/** Provides extensions for testing validation summaries generated by validators
  */
class ShouldExtensions[A](summary: ValidationWithData[A]) {

  /** Throws an exception if at least one failure occurred in this validation summary.
    */
  def shouldBeValid(): Unit = {
    if (!summary.isValid) {
      throw new ValidationTestingException(
        "\nExpected instance to be valid, but it had the following errors:\n%s".format(summary.validationFailures.map(_.message).mkString("\n")))
    }
  }

  /** Throws an exception if no errors occurred for the given field name in this summary
    */
  def shouldHaveValidationErrorFor(fieldName: Symbol): ShouldMessageKeyContinuationExtensions = {
    shouldHaveValidationErrorFor(fieldName.name)
  }

  /** Throws an exception if no errors occurred for the given field name in this summary
    */
  def shouldHaveValidationErrorFor(fieldName: String): ShouldMessageKeyContinuationExtensions = {
    val errors = summary.validationFailures filter { _.fieldName == fieldName }
    if (errors.isEmpty) {
      throw new ValidationTestingException(
        s"\nExpected instance to have errors for field $fieldName, but it didn't have any.")
    }
    new ShouldMessageKeyContinuationExtensions(fieldName, errors)
  }

  /** Throws an exception if an error occurred for the given field name in this summary
    */
  def shouldNotHaveValidationErrorFor(fieldName: Symbol): Unit = {
    shouldNotHaveValidationErrorFor(fieldName.name)
  }

  /** Throws an exception if an error occurred for the given field name in this summary
    */
  def shouldNotHaveValidationErrorFor(fieldName: String): Unit = {
    val errors = summary.validationFailures filter { _.fieldName == fieldName }
    if (errors.nonEmpty) {
      throw new ValidationTestingException(
        s"\nExpected instance to not have errors for field $fieldName, but it had the following errors:\n%s".format(summary.validationFailures.map(_.message).mkString("\n")))
    }
  }
}

class ShouldMessageKeyContinuationExtensions(fieldName: String, fieldFailures: List[ValidationFailure]) {

  /** Throws an exception if for the errors of the given field, the message key assigned to it does not match the passed
    * in message key
    */
  def withMessageKey(messageKey: String): ShouldMessageArgumentsContinuationExtensions = {
    val errorsOfKey = fieldFailures.filter { _.messageParts.messageKey == messageKey }
    if (errorsOfKey.isEmpty) {
      throw new ValidationTestingException(
        s"\nExpected instance to have errors for field $fieldName with message key $messageKey, but instead " +
          s"the following message keys were found: ${ fieldFailures.map(_.messageParts.messageKey) }")
    }
    new ShouldMessageArgumentsContinuationExtensions(fieldName, messageKey, errorsOfKey)
  }

}

class ShouldMessageArgumentsContinuationExtensions(fieldName: String,
                                                   messageKey: String,
                                                   errorsOfKey: List[ValidationFailure]) {

  /** Throws an exception if for the errors of the given field, with the given message key, format arguments do not match
    */
  def withFormatValues(formatValues: Any*): Unit = {
    val errors = errorsOfKey.filter { _.messageParts.messageFormatValues == formatValues.toList }
    if (errors.isEmpty) {
      throw new ValidationTestingException(
        s"\nExpected instance to have errors for field $fieldName with message key $messageKey and format values " +
          s"$formatValues, but instead " +
          s"the following format values were found: ${ errorsOfKey.map(_.messageParts.messageFormatValues).mkString(",") }")
    }
  }

}
